# AnyIO_UART_STM32
emulate UART using any IO , full duplex, max baudrate >= 115200

问1：是否可以使用IO模拟UART通讯？
问2：模拟UART波特率最大波特率能够做到多少？是否可以达到115200或以上？
问3：模拟UART的时序误差最小可以做到多少？
问4：模拟UART波特率较高时，如何降低CPU负载？


使用IO模拟UART并不复杂，但如何做到高性能的模拟UART则是一个挑战；
是否有可能使模拟UART满足以下特性：
1，全双工，半双工均可；
2，最大波特率可达115200及以上，甚至可以做到512000；
3，任意IO模拟TX RX；
4，发送时序可做到0误差；
5，CPU负载率小；

下面来探讨如何在STM32上实现满足以上特性的模拟UART。

基本思路：
  使用定时器触发DMA的方式模拟UART的收发；

具体实现，以通讯格式9600,8N1为例：
  将TIM2（或TIM3）的周期设为波特率周期104.2us，设一个通道的比较匹配值为52us；
  设置溢出中断触发DMA，比较匹配触发DMA；
  发送时，仅开启中断触发DMA，设置DMA搬运次数为10（1个起始位， 8个数据位，1个停止位），格式化要发送的数据保存到数组中（注解），
  然后启动定时器，当DMA搬运完成时，这个字节就发送完毕了；
  接收时，仅开启匹配中断触发DMA，设置DMA搬运次数为10，设置RX脚下降沿触发IO中断；当IO中断触发时，清零定时器并启动；
  当DMA搬运完成中断触发时，停止定时器，此时字节已经接收完毕；
  
缺点：
  需要使用1个定时器，2个DMA通道；
  并非严格意义的全双工，使用1个定时器时，收发不能同时进行；

总结：
  要实现同时收发，可以使用2个定时器分别触发DMA；
  发送时，CPU只要启动定时器就可以了，发送完成时可以不使用DMA中断，使用查询就可以；
  接收时，起始位的下降沿触发IO中断时，需要进入中断开启定时器，字节接收完成时也需要进入DMA中断读取接收到的字节；
  因此CPU只要在收发开始和结束时干预一下就好了；

